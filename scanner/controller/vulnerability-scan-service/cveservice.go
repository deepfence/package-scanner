//nolint:stylecheck
package vulnerability_scan_service

import (
	"fmt"
	"net/http"
	"os"

	"github.com/deepfence/package-scanner/output"
	"github.com/deepfence/package-scanner/scanner/grype"
	"github.com/deepfence/package-scanner/utils"
	"github.com/gin-gonic/gin"
	"github.com/rs/zerolog/log"
)

var (
	cveEsIndex = "cve"
	IngestAPI  = fmt.Sprintf("https://deepfence-internal-router:443/ingest/topics/%s", cveEsIndex)
	// IngestAPI = fmt.Sprintf("http://deepfence-rest-proxy:8082/topics/%s", cveEsIndex)
)

func New() *VulnerabilityScanService {
	return &VulnerabilityScanService{}
}

// Scan is a handler function for the /vulnerability-scan endpoint
// It takes a sbom and returns a json document containing the cve information
// e.g.
//
//	curl --location --request POST 'http://127.0.0.1:8085/vulnerability-mapper-api/vulnerability-scan?image-name=dum-im&image-id=abc1234&scan-id=xyz456' \
//	--header 'Content-Type: application/json' \
//	--data-raw '/*sbom json*/'
func (c *VulnerabilityScanService) Scan(gc *gin.Context) {
	// userInput is a vulnerability sbom in json format
	sbom, err := gc.GetRawData()
	if err != nil {
		log.Error().Err(err).Msg("Invalid post data")
		gc.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	nodeID := gc.Query("node_id")
	maskCveIds := gc.Query("mask_cve_ids")

	// validate sbom and return error if invalid
	// if err := utils.ValidateSbom(sbom); err != nil {
	//	gc.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
	//	log.Errorf("Invalid sbom: %s", err.Error())
	//	return
	//}

	scannerConfig := utils.Config{
		ConsoleURL:            "deepfence-internal-router",
		ConsolePort:           "443",
		ScanType:              gc.Query("scan_type"),
		ScanID:                gc.Query("scan_id"),
		NodeType:              gc.Query("node_type"),
		NodeID:                nodeID,
		HostName:              gc.Query("host_name"),
		ImageID:               gc.Query("image_id"),
		ContainerName:         gc.Query("container_name"),
		KubernetesClusterName: gc.Query("kubernetes_cluster_name"),
		MaskCveIds:            maskCveIds,
	}

	// start a go routine here
	go func() {
		publisher, err := output.NewPublisher(scannerConfig)
		if err != nil {
			return
		}
		publisher.PublishScanStatusPeriodic("SCAN_IN_PROGRESS")

		// go func() {
		// 	esErr := publisher.PublishSBOMtoES(sbom)
		// 	if esErr != nil {
		// 		log.Errorf("error in publishing sbom to es: %s", esErr.Error())
		// 	}
		// }()

		// create a temporary file to store the user input(SBOM)
		file, err := utils.CreateTempFile(sbom)
		if err != nil {
			publisher.PublishScanError(err.Error())
			log.Error().Err(err).Msg("error on CreateTempFile")
			return
		}

		defer os.Remove(file.Name())

		vulnerabilities, err := grype.Scan(scannerConfig.GrypeBinPath,
			scannerConfig.GrypeConfigPath, file.Name(), nil)
		if err != nil {
			publisher.PublishScanError(err.Error())
			log.Error().Err(err).Msg("error on grype.Scan")
			return
		}

		_, err = grype.PopulateFinalReport(vulnerabilities, scannerConfig)
		if err != nil {
			publisher.PublishScanError(err.Error())
			log.Error().Err(err).Msg("error on PopulateFinalReport")
			return
		}

		publisher.StopPublishScanStatus()
		publisher.PublishScanStatusMessage("", "COMPLETED")
		log.Info().Str("node_id", nodeID).Msg("Scan completed")
	}()
	gc.JSON(http.StatusOK, gin.H{"status": "scan started"})
}
